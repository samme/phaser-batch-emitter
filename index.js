// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";
  var BatchEmitter, BatchParticle, Cache, Core, PIXI, Phaser, Point, Rectangle, freeze, getRandomItem, max, min, ref, shuffle,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Phaser = this.Phaser, PIXI = this.PIXI;

  max = Math.max, min = Math.min;

  freeze = Object.freeze;

  Cache = Phaser.Cache, Point = Phaser.Point, Rectangle = Phaser.Rectangle;

  ref = Phaser.ArrayUtils, getRandomItem = ref.getRandomItem, shuffle = ref.shuffle;

  Core = Phaser.Component.Core;

  Phaser.BatchParticle = BatchParticle = (function(superClass) {
    extend(BatchParticle, superClass);

    BatchParticle.prototype.anchor = freeze(new Point(0.5, 0.5));

    BatchParticle.prototype.position = freeze(new Point);

    BatchParticle.prototype.scale = freeze(new Point(1, 1));

    BatchParticle.prototype.type = Phaser.IMAGE;

    BatchParticle.prototype.vr = 0;

    BatchParticle.prototype.vx = 0;

    BatchParticle.prototype.vy = 0;

    function BatchParticle(game, x, y, key, frame) {
      if (x == null) {
        x = 0;
      }
      if (y == null) {
        y = 0;
      }
      if (key == null) {
        key = null;
      }
      if (frame == null) {
        frame = null;
      }
      PIXI.Sprite.call(this, Cache.DEFAULT);
      Core.init.call(this, game, x, y, key, frame);
    }

    return BatchParticle;

  })(PIXI.Sprite);

  Core.install.call(BatchParticle.prototype, ['Animation', 'BringToTop', 'Destroy', 'LifeSpan', 'LoadTexture', 'Reset', 'Smoothed']);

  Phaser.BatchEmitter = BatchEmitter = (function(superClass) {
    extend(BatchEmitter, superClass);

    BatchEmitter.add = function(game, x, y, maxParticles, parent, name, addToStage) {
      if (parent == null) {
        parent = game.world;
      }
      return this.create(game, x, y, maxParticles, parent, name, addToStage);
    };

    BatchEmitter.create = function(game, x, y, maxParticles, parent, name, addToStage) {
      var emitter;
      emitter = new this(game);
      emitter.configure(x, y, maxParticles, parent, name, addToStage);
      return emitter;
    };

    BatchEmitter.prototype._flowLimit = null;

    BatchEmitter.prototype._flowQuantity = null;

    BatchEmitter.prototype.alphaData = null;

    BatchEmitter.prototype.angularDrag = 0;

    BatchEmitter.prototype.area = null;

    BatchEmitter.prototype.autoAlpha = false;

    BatchEmitter.prototype.autoScale = false;

    BatchEmitter.prototype.debug = false;

    BatchEmitter.prototype.emitX = 0;

    BatchEmitter.prototype.emitY = 0;

    BatchEmitter.prototype.frequency = 100;

    BatchEmitter.prototype.gravity = 0;

    BatchEmitter.prototype.lifespan = 2000;

    BatchEmitter.prototype.log = false;

    BatchEmitter.prototype.maxParticleAlpha = 1;

    BatchEmitter.prototype.minParticleAlpha = 1;

    BatchEmitter.prototype.maxParticles = 50;

    BatchEmitter.prototype.maxParticleScale = null;

    BatchEmitter.prototype.maxParticleSpeed = null;

    BatchEmitter.prototype.maxRotation = 0;

    BatchEmitter.prototype.minParticleScale = null;

    BatchEmitter.prototype.minParticleSpeed = null;

    BatchEmitter.prototype.minRotation = 0;

    BatchEmitter.prototype.on = false;

    BatchEmitter.prototype.particleAnchor = null;

    BatchEmitter.prototype.particleBringToTop = false;

    BatchEmitter.prototype.particleDrag = null;

    BatchEmitter.prototype.particleSendToBack = false;

    BatchEmitter.prototype.randomFrame = false;

    BatchEmitter.prototype.scaleData = null;

    Object.defineProperty(BatchEmitter.prototype, "length", {
      get: function() {
        return this.children.length;
      },
      set: function(val) {
        return this.children.length = val;
      }
    });

    function BatchEmitter() {
      BatchEmitter.__super__.constructor.apply(this, arguments);
      this.classType = Phaser.BatchParticle;
      this.debugInfo = {};
      this.maxParticleScale = new Point(1, 1);
      this.maxParticleSpeed = new Point;
      this.minParticleScale = new Point(1, 1);
      this.minParticleSpeed = new Point;
      this.particleAnchor = new Point(0.5, 0.5);
    }

    BatchEmitter.prototype._explode = function(quantity) {
      var child, j, len, ref1;
      if (this.log) {
        console.log("_explode", quantity);
      }
      ref1 = this.children;
      for (j = 0, len = ref1.length; j < len; j++) {
        child = ref1[j];
        if (!(!child.exists)) {
          continue;
        }
        this.resetChild(child);
        quantity -= 1;
        if (!(quantity > 0)) {
          break;
        }
      }
    };

    BatchEmitter.prototype._renderCanvas = PIXI.SpriteBatch.prototype._renderCanvas;

    BatchEmitter.prototype._renderWebGL = PIXI.SpriteBatch.prototype._renderWebGL;

    BatchEmitter.prototype.add = function(child, silent, index) {
      if (silent == null) {
        silent = false;
      }
      if (child.parent === this) {
        return child;
      }
      if (index == null) {
        child.z = this.children.length;
        this.addChild(child);
      } else {
        this.addChildAt(child, index);
        this.updateZ();
      }
      if (this.cursor == null) {
        this.cursor = child;
      }
      return child;
    };

    BatchEmitter.prototype.configure = function(emitX1, emitY1, maxParticles1) {
      this.emitX = emitX1;
      this.emitY = emitY1;
      this.maxParticles = maxParticles1 != null ? maxParticles1 : 50;
      if (this.log) {
        console.log("configure", this.emitX, this.emitY, this.maxParticles);
      }
      return this;
    };

    BatchEmitter.prototype.copyAreaFrom = function(rect) {
      if (this.area) {
        this.area.copyFrom(rect);
      } else {
        this.area = rect.clone();
      }
      return this;
    };

    BatchEmitter.prototype.copyPositionFrom = function(pos) {
      this.emitX = pos.x;
      this.emitY = pos.y;
      return this;
    };

    BatchEmitter.prototype.create = function(x, y, key, frame, exists, index) {
      var child;
      if (exists == null) {
        exists = true;
      }
      child = new this.classType(this.game, x, y, key, frame);
      child.exists = child.visible = child.alive = exists;
      child.anchor = this.particleAnchor;
      this.add(child, false, index);
      return child;
    };

    BatchEmitter.prototype.createTimer = function() {
      if (this.log) {
        console.log("create timer");
      }
      this.destroyTimer();
      this._timer = this.game.time.create();
      this._timer.loop(this.frequency, this.onLoop, this);
      this._timer.start();
      if (this.log) {
        console.log("start timer", this._timer.next);
      }
    };

    BatchEmitter.prototype.destroy = function() {
      BatchEmitter.__super__.destroy.apply(this, arguments);
      this.destroyTimer();
      if (this.log) {
        console.log("destroyed");
      }
    };

    BatchEmitter.prototype.destroyTimer = function() {
      if (this.log) {
        console.log("destroyTimer", this._timer);
      }
      if (this._timer) {
        this._timer.destroy();
      }
    };

    BatchEmitter.prototype.explode = function(lifespan, quantity) {
      if (lifespan == null) {
        lifespan = this.lifespan;
      }
      if (quantity == null) {
        quantity = this.maxParticles;
      }
      if (this.log) {
        console.log("explode", lifespan, quantity);
      }
      this.start(true, lifespan, 0, quantity, false);
      this.game.time.events.add(lifespan, this.kill, this);
      return this;
    };

    BatchEmitter.prototype.flow = function(lifespan, frequency, quantity, limit, immediate) {
      if (lifespan == null) {
        lifespan = this.lifespan;
      }
      if (frequency == null) {
        frequency = this.frequency;
      }
      if (quantity == null) {
        quantity = 1;
      }
      if (limit == null) {
        limit = -1;
      }
      if (immediate == null) {
        immediate = true;
      }
      if (this.log) {
        console.log("flow", lifespan, frequency, quantity, limit, immediate);
      }
      this._flowLimit = limit;
      if (immediate) {
        this.pendingEmit = true;
      }
      this.start(false, lifespan, frequency, quantity);
      return this;
    };

    BatchEmitter.prototype.flowAuto = function(lifespan, frequency, quantity) {
      if (this.log) {
        console.log("flowAuto", lifespan, frequency, quantity);
      }
      switch (false) {
        case !(lifespan == null):
          lifespan = this.maxParticles * frequency / quantity;
          if (this.log) {
            console.log("let lifespan =", lifespan);
          }
          break;
        case !(frequency == null):
          frequency = quantity * lifespan / this.maxParticles;
          if (this.log) {
            console.log("let frequency =", frequency);
          }
          break;
        case !(quantity == null):
          quantity = this.maxParticles * frequency / lifespan;
          if (this.log) {
            console.log("let quantity =", quantity);
          }
          break;
        default:
          throw new Error("You must pass exactly 1 null value for lifespan, frequency, or quantity");
      }
      this.flow(lifespan, frequency, quantity);
      return this;
    };

    BatchEmitter.prototype.kill = function() {
      if (this.log) {
        console.log("kill");
      }
      this.alive = this.exists = this.on = this.visible = false;
      if (this._timer) {
        this._timer.pause();
      }
      this.updateDebugInfo();
      return this;
    };

    BatchEmitter.prototype.makeParticles = function(key, frame, quantity) {
      if (quantity == null) {
        quantity = this.maxParticles;
      }
      if (this.log) {
        console.log("makeParticles", key, frame, quantity);
      }
      if (key != null) {
        this.particleKey = key;
      }
      if (frame != null) {
        this.particleFrame = frame;
      }
      if (this.log) {
        console.log("createMultiple", quantity, this.particleKey, this.particleFrame);
      }
      this.createMultiple(quantity, this.particleKey, this.particleFrame);
      if (this.log) {
        console.log("length", this.length);
      }
      return this;
    };

    BatchEmitter.prototype.onLoop = function() {
      this.pendingEmit = true;
    };

    BatchEmitter.prototype.postUpdate = function() {
      if (this.fixedToCamera) {
        this.x = this.game.camera.view.x + this.cameraOffset.x;
        this.y = this.game.camera.view.y + this.cameraOffset.y;
      }
    };

    BatchEmitter.prototype.preUpdate = function() {
      if (this.pendingDestroy) {
        this.destroy();
        return false;
      }
      if (!(this.exists && this.parent.exists)) {
        this.renderOrderID = -1;
        return false;
      }
      return true;
    };

    BatchEmitter.prototype.resetChild = function(child, x, y) {
      var emitX, emitY, position, rnd, scale, xMax, xMin, yMax, yMin;
      rnd = this.game.rnd;
      emitX = this.emitX, emitY = this.emitY;
      position = child.position, scale = child.scale;
      xMax = this.maxParticleScale.x;
      xMin = this.minParticleScale.x;
      yMax = this.maxParticleScale.y;
      yMin = this.minParticleScale.y;
      child.reset(x, y);
      if (this.lifespan) {
        child.lifespan = this.lifespan;
      }
      if (this.maxParticleSpeed.x !== 0 || this.minParticleSpeed.x !== 0) {
        child.vx = this.maxParticleSpeed.x === this.minParticleSpeed.x ? this.maxParticleSpeed.x : rnd.realInRange(this.minParticleSpeed.x, this.maxParticleSpeed.x);
      }
      if (this.maxParticleSpeed.y !== 0 || this.minParticleSpeed.y !== 0) {
        child.vy = this.maxParticleSpeed.y === this.minParticleSpeed.y ? this.maxParticleSpeed.y : rnd.realInRange(this.minParticleSpeed.y, this.maxParticleSpeed.y);
      }
      if (this.area) {
        if (x == null) {
          position.x = emitX + this.area.randomX;
        }
        if (y == null) {
          position.y = emitY + this.area.randomY;
        }
      } else {
        position.x = emitX;
        position.y = emitY;
      }
      if (this.maxParticleAlpha !== 1 || this.minParticleAlpha !== 1) {
        child.alpha = this.autoAlpha || this.maxParticleAlpha === this.minParticleAlpha ? this.maxParticleAlpha : rnd.realInRange(this.minParticleAlpha, this.maxParticleAlpha);
      }
      if (xMax !== 1 || xMin !== 1) {
        scale.x = this.autoScale || xMax === xMin ? xMax : rnd.realInRange(xMin, xMax);
      }
      if (yMax !== 1 || yMin !== 1) {
        scale.y = this.autoScale || yMax === yMin ? yMax : xMin === yMin && xMax === yMax ? scale.x : rnd.realInRange(yMin, yMax);
      }
      if (this.maxRotation !== 0 || this.minRotation !== 0) {
        child.vr = this.maxRotation === this.minRotation ? this.maxRotation : rnd.realInRange(this.minRotation, this.maxRotation);
      }
      if (this.particleBringToTop) {
        this.bringToTop(child);
      } else if (this.particleSendToBack) {
        this.sendToBack(child);
      }
      if (this.randomFrame) {
        child.frame = getRandomItem(this.particleFrame);
      }
      return child;
    };

    BatchEmitter.prototype.remove = function(child, destroy, silent) {
      var removed;
      if (destroy == null) {
        destroy = false;
      }
      if (silent == null) {
        silent = false;
      }
      if (this.children.length === 0) {
        return false;
      }
      removed = this.removeChild(child);
      this.updateZ();
      if (this.cursor === child) {
        this.next();
      }
      if (destroy && removed) {
        removed.destroy(true);
      }
      return true;
    };

    BatchEmitter.prototype.revive = function() {
      if (this.log) {
        console.log("revive");
      }
      this.alive = this.exists = this.visible = true;
      this.updateDebugInfo();
      return this;
    };

    BatchEmitter.prototype.setAlpha = function(minParticleAlpha, maxParticleAlpha) {
      this.minParticleAlpha = minParticleAlpha;
      this.maxParticleAlpha = maxParticleAlpha != null ? maxParticleAlpha : this.minParticleAlpha;
      this.autoAlpha = false;
      return this;
    };

    BatchEmitter.prototype.setAlphaTween = function(start, end, duration, easing, yoyo) {
      if (duration == null) {
        duration = this.lifespan;
      }
      if (easing == null) {
        easing = Phaser.Easing.Default;
      }
      if (this.log) {
        console.log("setAlphaTween", start, end, duration, easing.name, yoyo);
      }
      this.alphaData = this.game.make.tween({
        alpha: start
      }).to({
        alpha: end
      }, duration, easing, false, null, null, yoyo).generateData();
      this.autoAlpha = true;
      return this;
    };

    BatchEmitter.prototype.setAnchor = function(x, y) {
      this.particleAnchor.set(x, y);
      return this;
    };

    BatchEmitter.prototype.setAngularDrag = function(angularDrag1) {
      this.angularDrag = angularDrag1;
      return this;
    };

    BatchEmitter.prototype.setArea = function(x, y, width, height) {
      if (!this.area) {
        this.area = new Rectangle;
      }
      this.area.setTo(x, y, width, height);
      return this;
    };

    BatchEmitter.prototype.setDrag = function(x, y) {
      if (!this.particleDrag) {
        this.particleDrag = new Point;
      }
      this.particleDrag.x = x;
      this.particleDrag.y = y;
      return this;
    };

    BatchEmitter.prototype.setGravity = function(gravity1) {
      this.gravity = gravity1;
      return this;
    };

    BatchEmitter.prototype.setPosition = function(emitX1, emitY1) {
      this.emitX = emitX1;
      this.emitY = emitY1;
      return this;
    };

    BatchEmitter.prototype.setRotation = function(minRotation, maxRotation) {
      this.minRotation = minRotation;
      this.maxRotation = maxRotation;
      return this;
    };

    BatchEmitter.prototype.setScale = function(xMin, xMax, yMin, yMax) {
      if (xMax == null) {
        xMax = xMin;
      }
      if (yMin == null) {
        yMin = xMin;
      }
      if (yMax == null) {
        yMax = xMax;
      }
      if (this.log) {
        console.log("setScale", xMin, xMax, yMin, yMax);
      }
      this.minParticleScale.set(xMin, yMin);
      this.maxParticleScale.set(xMax, yMax);
      if (this.log) {
        console.log("minParticleScale", this.minParticleScale.toString());
      }
      if (this.log) {
        console.log("maxParticleScale", this.maxParticleScale.toString());
      }
      this.autoScale = false;
      return this;
    };

    BatchEmitter.prototype.setScaleTween = function(xStart, xEnd, yStart, yEnd, duration, easing, yoyo) {
      if (yStart == null) {
        yStart = xStart;
      }
      if (yEnd == null) {
        yEnd = xEnd;
      }
      if (duration == null) {
        duration = this.lifespan;
      }
      if (easing == null) {
        easing = Phaser.Easing.Default;
      }
      if (yoyo == null) {
        yoyo = false;
      }
      if (this.log) {
        console.log("setScaleTween", "x: " + xStart + ", y: " + yStart, "x: " + xEnd + ", y: " + yEnd + ")", duration, easing.name);
      }
      this.scaleData = this.game.make.tween({
        x: xStart,
        y: yStart
      }).to({
        x: xEnd,
        y: yEnd
      }, duration, easing, false, null, null, yoyo).generateData();
      this.autoScale = true;
      return this;
    };

    BatchEmitter.prototype.setSize = function(width, height) {
      if (!this.area) {
        this.area = new Rectangle;
      }
      this.area.width = width;
      this.area.height = height;
      if (this.log) {
        console.log("setSize", this.area.toString());
      }
      return this;
    };

    BatchEmitter.prototype.setSpeed = function(xMin, xMax, yMin, yMax) {
      if (xMax == null) {
        xMax = xMin;
      }
      if (yMin == null) {
        yMin = xMin;
      }
      if (yMax == null) {
        yMax = xMax;
      }
      if (this.log) {
        console.log("setSpeed", xMin, xMax, yMin, yMax);
      }
      this.setXSpeed(xMin, xMax);
      this.setYSpeed(yMin, yMax);
      return this;
    };

    BatchEmitter.prototype.setXSpeed = function(xMin, xMax) {
      if (this.log) {
        console.log("setXSpeed", xMin, xMax);
      }
      this.minParticleSpeed.x = xMin;
      this.maxParticleSpeed.x = xMax;
      return this;
    };

    BatchEmitter.prototype.setYSpeed = function(yMin, yMax) {
      if (this.log) {
        console.log("setYSpeed", yMin, yMax);
      }
      this.minParticleSpeed.y = yMin;
      this.maxParticleSpeed.y = yMax;
      return this;
    };

    BatchEmitter.prototype.shuffle = function() {
      shuffle(this.children);
      return this;
    };

    BatchEmitter.prototype.start = function(explode, lifespan, frequency, quantity, forceQuantity) {
      if (this.log) {
        console.log("start", explode, lifespan, frequency, quantity, forceQuantity);
      }
      if (lifespan != null) {
        this.lifespan = lifespan;
      }
      if (frequency != null) {
        this.frequency = frequency;
      }
      if (explode) {
        this.destroyTimer();
        this._flowLimit = -1;
        this._flowQuantity = -1;
        this.on = false;
        this._explode(quantity, this.emitX, this.emitY);
      } else {
        this.createTimer();
        this._flowQuantity = quantity;
        this.on = true;
      }
    };

    BatchEmitter.prototype.update = function() {
      var _flowQuantity, alive, alphaData, alphaLength, angularDrag, angularDragDelta, antiLifetime, autoAlpha, autoScale, child, children, dead, debug, debugInfo, dragXDelta, dragYDelta, gravity, gravityDelta, hasFlowLimit, i, isOn, killed, lifespan, lifetime, particleDrag, pendingEmit, physicsElapsed, physicsElapsedMS, position, ref1, ref2, revived, scale, scaleData, scaleLength, stage;
      if (!this.exists) {
        return;
      }
      if (this._timer) {
        if (this.on) {
          if (this._timer.paused) {
            this._timer.resume();
          }
        } else {
          if (this._timer.running) {
            this._timer.pause();
          }
        }
      }
      stage = this.game.stage;
      ref1 = this.game.time, physicsElapsed = ref1.physicsElapsed, physicsElapsedMS = ref1.physicsElapsedMS;
      _flowQuantity = this._flowQuantity, alphaData = this.alphaData, angularDrag = this.angularDrag, autoAlpha = this.autoAlpha, autoScale = this.autoScale, children = this.children, debug = this.debug, debugInfo = this.debugInfo, gravity = this.gravity, lifespan = this.lifespan, particleDrag = this.particleDrag, pendingEmit = this.pendingEmit, scaleData = this.scaleData;
      alphaLength = alphaData != null ? alphaData.length : void 0;
      isOn = this.on;
      hasFlowLimit = this._flowLimit !== -1;
      scaleLength = scaleData != null ? scaleData.length : void 0;
      if (angularDrag) {
        angularDragDelta = angularDrag * physicsElapsed;
      }
      if (gravity) {
        gravityDelta = gravity * physicsElapsed;
      }
      if (particleDrag) {
        dragXDelta = particleDrag.x * physicsElapsed;
        dragYDelta = particleDrag.y * physicsElapsed;
      }
      if (debug) {
        alive = 0;
        dead = 0;
        revived = 0;
        killed = 0;
      }
      i = 0;
      while (child = children[i++]) {
        if (child.lifespan > 0) {
          child.lifespan -= physicsElapsedMS;
          if (child.lifespan <= 0) {
            child._exists = child.visible = false;
            child.renderOrderID = -1;
            if (debug) {
              killed += 1;
            }
          }
        }
        child.renderOrderID = child._exists ? stage.currentRenderOrderID++ : child.renderOrderID = -1;
        if (pendingEmit && isOn && !child._exists) {
          this.resetChild(child);
          if (debug) {
            revived += 1;
          }
          _flowQuantity -= 1;
          if (_flowQuantity === 0) {
            pendingEmit = false;
          }
          if (hasFlowLimit) {
            this._flowLimit -= 1;
            if (this._flowLimit === 0) {
              this.on = false;
              pendingEmit = false;
            }
          }
          this.pendingEmit = pendingEmit;
        }
        if (child._exists) {
          position = child.position;
          child.visible = true;
          if (debug) {
            alive += 1;
          }
          lifetime = child.lifespan / lifespan;
          antiLifetime = 1 - lifetime;
          if (angularDrag) {
            if (child.vr > 0) {
              child.vr = max(0, child.vr - angularDragDelta);
            } else if (child.vr < 0) {
              child.vr = min(0, child.vr + angularDragDelta);
            }
          }
          if (autoAlpha) {
            child.alpha = (alphaData[~~(alphaLength * antiLifetime) - 1] || alphaData[0]).alpha;
          }
          if (autoScale) {
            scale = scaleData[~~(scaleLength * antiLifetime) - 1] || scaleData[0];
            child.scale.x = scale.x;
            child.scale.y = scale.y;
          }
          if (gravity) {
            child.vy += gravityDelta;
          }
          if (particleDrag) {
            if (child.vx > 0) {
              child.vx = max(0, child.vx - dragXDelta);
            } else if (child.vx < 0) {
              child.vx = min(0, child.vx + dragXDelta);
            }
            if (child.vy > 0) {
              child.vy = max(0, child.vy - dragYDelta);
            } else if (child.vy < 0) {
              child.vy = min(0, child.vy - dragYDelta);
            }
          }
          position.x += child.vx * physicsElapsed;
          position.y += child.vy * physicsElapsed;
          child.rotation += child.vr * physicsElapsed;
        } else {
          if (debug) {
            dead += 1;
          }
        }
      }
      if (this.debug) {
        debugInfo.alive = alive;
        debugInfo.dead = dead;
        debugInfo.killed = killed;
        debugInfo.revived = revived;
        debugInfo.total = this.length;
        debugInfo.flowLimit = this._flowLimit;
        debugInfo.flowQuantity = _flowQuantity;
        debugInfo.next = (ref2 = this._timer) != null ? ref2.duration : void 0;
        debugInfo.on = isOn;
      }
    };

    BatchEmitter.prototype.updateDebugInfo = function() {
      if (this.debug) {
        this.debugInfo.alive = this.alive;
        this.debugInfo.on = this.on;
        this.debugInfo.exists = this.exists;
        this.debugInfo.visible = this.visible;
      }
    };

    BatchEmitter.prototype.updateTransform = PIXI.SpriteBatch.prototype.updateTransform;

    return BatchEmitter;

  })(Phaser.SpriteBatch);

  Phaser.GameObjectCreator.prototype.batchEmitter = function(x, y, maxParticles, parent, name, addToStage) {
    return BatchEmitter.create(this.game, x, y, maxParticles, parent, name, addToStage);
  };

  Phaser.GameObjectFactory.prototype.batchEmitter = function(x, y, maxParticles, parent, name, addToStage) {
    return BatchEmitter.add(this.game, x, y, maxParticles, parent, name, addToStage);
  };

}).call(this);
