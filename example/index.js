// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";
  var Back, Circular, Cubic, DEFAULT_STATE, Default, Exponential, FONT, FOREVER, Linear, PI, Phaser, Quadratic, SECOND, STYLE, Sinusoidal, SpiralingWatcher, TURN, atan2, captionUpdateInterval, cos, fpsProblems, lastFpsProblemInterval, lastFpsProblemTime, linear, max, min, ref, sin, startGame, states,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Phaser = this.Phaser;

  atan2 = Math.atan2, cos = Math.cos, max = Math.max, min = Math.min, PI = Math.PI, sin = Math.sin;

  ref = Phaser.Easing, Back = ref.Back, Circular = ref.Circular, Cubic = ref.Cubic, Default = ref.Default, Exponential = ref.Exponential, Linear = ref.Linear, Quadratic = ref.Quadratic, Sinusoidal = ref.Sinusoidal;

  linear = Phaser.Math.linear;

  SECOND = Phaser.Timer.SECOND;

  DEFAULT_STATE = "balls";

  FONT = "16px monospace";

  FOREVER = 0;

  STYLE = {
    backgroundColor: "black",
    fill: "white",
    font: FONT
  };

  TURN = 2 * PI;

  captionUpdateInterval = 100;

  fpsProblems = 0;

  lastFpsProblemInterval = 0;

  lastFpsProblemTime = 0;

  Phaser.BatchEmitter.prototype.debug = true;

  Phaser.BatchEmitter.prototype.log = true;

  SpiralingWatcher = (function(superClass) {
    extend(SpiralingWatcher, superClass);

    function SpiralingWatcher() {
      return SpiralingWatcher.__super__.constructor.apply(this, arguments);
    }

    SpiralingWatcher.prototype.init = function() {
      this.spiraling = new Phaser.Signal;
    };

    SpiralingWatcher.prototype.update = function() {
      if (this.game.time.suggestedFps < 30) {
        this.spiraling.dispatch();
      }
    };

    return SpiralingWatcher;

  })(Phaser.Plugin);

  states = {
    boot: {
      "private": true,
      init: function() {
        this.game.forceSingleUpdate = false;
        this.game.fpsProblemNotifier.add(this.onFpsProblem.bind(this));
        this.game.timing = this.game.plugins.add(Phaser.Plugin.AdvancedTiming, {
          mode: "graph",
          visible: false
        });
        this.game.timing.activeDisplay.alignIn(this.world.bounds, Phaser.TOP_RIGHT);
        this.game.watcher = this.game.plugins.add(SpiralingWatcher);
        this.game.watcher.spiraling.add(this.onSpiraling.bind(this));
        lastFpsProblemTime = this.game.time.time;
      },
      preload: function() {
        var data, key, ref1, ref2, url;
        this.load.path = 'example/assets/';
        ref1 = {
          bubble: 'bubble256.png',
          circle: 'blue-circle.png',
          colormap: 'colormap.png',
          fireball: 'fireball.png',
          fog: 'particle1.png',
          hsl: 'hsl.png',
          rabbit: 'wabbit.png',
          rain: 'rain.png',
          raster: 'yellow-pink-raster.png',
          star: 'star.png',
          star2: 'star2.png'
        };
        for (key in ref1) {
          url = ref1[key];
          this.load.image(key, url);
        }
        ref2 = {
          balls: ['balls.png', 17, 17],
          food: ['fruitnveg32wh37.png', 32, 32, 36],
          gameboy: ['gameboy_seize_color_40x60.png', 40, 60],
          snowflakes: ['snowflakes_large.png', 64, 64]
        };
        for (key in ref2) {
          data = ref2[key];
          this.load.spritesheet(key, data[0], data[1], data[2]);
        }
      },
      create: function() {
        this.createCaption();
        this.createMenu();
        this.bindControls();
        this.state.onStateChange.add(this.onStateChange.bind(this));
        this.state.start(DEFAULT_STATE);
      },
      bindControls: function() {
        var id;
        id = document.getElementById.bind(document);
        this.$restart = id("restart");
        id("debug").addEventListener("change", this.onDebugChanged.bind(this));
        id("fullscreen").addEventListener("click", this.onFullscreenClicked.bind(this));
        id("menu").addEventListener("change", this.onMenuChanged.bind(this));
        id("performance").addEventListener("change", this.onPerformanceChanged.bind(this));
        this.$restart.addEventListener("click", this.restart.bind(this));
      },
      captionUpdate: function() {
        var emitter, key, val;
        if (this.alive) {
          emitter = this.game.state.getCurrentState().emitter;
          if (emitter && emitter.debug) {
            this.text = ((function() {
              var ref1, results;
              ref1 = emitter.debugInfo;
              results = [];
              for (key in ref1) {
                val = ref1[key];
                results.push(key + ": " + val);
              }
              return results;
            })()).join("\t");
          }
          this.alive = false;
        }
      },
      createCaption: function() {
        var caption;
        caption = this.game.caption = this.stage.addChild(this.game.make.text(0, 0, "Hello", STYLE)).alignIn(this.world.bounds, Phaser.BOTTOM_LEFT);
        caption.exists = false;
        caption.update = this.captionUpdate.bind(caption);
      },
      createMenu: function() {
        var $menu, $opt, el, i, len, name, names, state, stateName;
        el = document.createElement.bind(document);
        names = [];
        for (stateName in states) {
          state = states[stateName];
          if (!state["private"]) {
            names.push(stateName);
          }
        }
        $menu = document.getElementById("menu");
        $menu.appendChild(el("option"));
        for (i = 0, len = names.length; i < len; i++) {
          name = names[i];
          $opt = el("option");
          $opt.textContent = name;
          $menu.appendChild($opt);
        }
        this.$menu = $menu;
      },
      onDebugChanged: function(event) {
        this.game.caption.exists = event.target.checked;
      },
      onFpsProblem: function() {
        var time;
        time = this.game.time.time;
        fpsProblems += 1;
        lastFpsProblemInterval = time - lastFpsProblemTime;
        lastFpsProblemTime = time;
        console.warn("fpsProblem (" + fpsProblems + ") +" + lastFpsProblemInterval + "ms " + this.game._spiraling);
      },
      onFullscreenClicked: function() {
        this.scale.startFullScreen();
      },
      onMenuChanged: function(event) {
        console.log(event.target.value);
        this.state.start(event.target.value);
      },
      onPerformanceChanged: function() {
        this.game.timing.visible = !this.game.timing.visible;
      },
      onSpiraling: function() {
        this.game.state.start("fpsProblem");
      },
      onStateChange: function(current, prev) {
        this.resetFpsProblemCount();
        this.game.lockRender = false;
        this.refreshMenu(current);
        this.$restart.disabled = this.state.getCurrentState()["private"];
        this.game.time.events.loop(captionUpdateInterval, this.pokeCaption, this);
        console.log("start", current, prev);
        console.log("lockRender", this.game.lockRender);
      },
      pokeCaption: function() {
        this.game.caption.alive = true;
      },
      refreshMenu: function(state) {
        this.$menu.value = state;
      },
      resetFpsProblemCount: function() {
        fpsProblems = 0;
        console.log("resetFpsProblemCount", fpsProblems);
      },
      restart: function() {
        this.state.restart();
      }
    },
    balls: {
      create: function() {
        var height, maxParticles, ref1, width;
        ref1 = this.world, height = ref1.height, width = ref1.width;
        this.emitter = this.add.batchEmitter(this.world.bounds.left, this.world.bounds.bottom, maxParticles = 10000).setAngularDrag(TURN / 60).setDrag(width / 96, 0).setGravity(height / 8).setRotation(-2 * TURN, 2 * TURN).setXSpeed(width / -4, width / 4).setYSpeed(height / -2, 0).makeParticles('balls', [0, 1, 2, 3, 4], ~~(maxParticles / 5)).flow(5 * SECOND, 20, maxParticles / 250);
        this.add.tween(this.emitter).to({
          emitX: this.world.bounds.right
        }, 2.5 * SECOND, Sinusoidal.InOut, true, 0, -1, true);
      },
      update: function() {
        var child, height, i, len, ref1, ref2, ref3, width, x, y;
        ref1 = this.world, height = ref1.height, width = ref1.width;
        ref2 = this.emitter.children;
        for (i = 0, len = ref2.length; i < len; i++) {
          child = ref2[i];
          if (!child.visible) {
            continue;
          }
          ref3 = child.position, x = ref3.x, y = ref3.y;
          if (x < 0 || x > width) {
            child.vx *= -1;
          }
          if (y > height) {
            child.vy *= -1;
          }
        }
      }
    },
    bubbles: {
      create: function() {
        var lifespan, maxParticles;
        lifespan = 5 * SECOND;
        this.emitter = this.add.batchEmitter(0, 0, maxParticles = 500).setAlpha(0.1, 0.3).setArea(this.world.bounds.left, this.world.bounds.bottom, this.world.width, 1).setGravity(-10).setRotation(TURN / -5, TURN / 5).setScaleTween(0, 0.5, 0, 0.5, lifespan, Back.Out).setXSpeed(-50, 50).setYSpeed(-50, -150).makeParticles('bubble').flow(lifespan, 10, 1);
      }
    },
    colors: {
      create: function() {
        var lifespan, maxParticles;
        lifespan = 10 * SECOND;
        this.emitter = this.add.batchEmitter(this.world.bounds.left, this.world.bounds.top, maxParticles = 10).setAlphaTween(0, 0.25, lifespan, Sinusoidal.InOut, true).setAnchor(0.5, 0).setArea(0, this.world.bounds.bottom, this.world.width, 1).setScaleTween(4, -4, -4, -4, lifespan, Sinusoidal.InOut, true).setSize(this.world.width, 1).setXSpeed(this.world.width / -10, this.world.width / 10).makeParticles('colormap').flowAuto(lifespan, null, 1);
      }
    },
    explode: {
      create: function() {
        var bounds, height, keys, maxParticles, ref1, width;
        ref1 = this.world, bounds = ref1.bounds, height = ref1.height, width = ref1.width;
        this.emitter = this.add.batchEmitter(0, 0, maxParticles = 10000).setArea(bounds.left, bounds.bottom, width, 1).setGravity(height / 4).setRotation(-TURN, TURN).setSpeed(width / -15, width / 15, height * -1.5, height * -0.5).makeParticles('food', keys = Phaser.ArrayUtils.numberArray(0, 24), maxParticles / keys.length).explode(15 * SECOND);
      },
      update: function() {
        var child, height, i, len, ref1, ref2, width;
        ref1 = this.world, height = ref1.height, width = ref1.width;
        ref2 = this.emitter.children;
        for (i = 0, len = ref2.length; i < len; i++) {
          child = ref2[i];
          if (child.visible && (child.position.x < 0 || child.position.x > width || child.vy > 0 && child.position.y > height)) {
            child.kill();
          }
        }
      }
    },
    field: {
      create: function() {
        var bounds, lifespan, maxParticles, rnd;
        bounds = this.world.bounds.clone().scale(0.5).offset(this.game.width / 4, this.game.height / 4);
        lifespan = 10 * SECOND;
        rnd = this.game.rnd;
        this.emitter = this.add.batchEmitter(bounds.left, bounds.top, maxParticles = 100).setAlphaTween(0, 0.1, lifespan, Cubic.InOut, true).setPosition(bounds.left, bounds.top).setScaleTween(0, 1, 0, 1, lifespan, Cubic.InOut, true).makeParticles('circle').flowAuto(lifespan, 100, null);
        this.add.tween(this.emitter).to({
          emitX: bounds.right
        }, lifespan * rnd.between(1, 5), Sinusoidal.InOut, true, 0, -1, true);
        this.add.tween(this.emitter).to({
          emitY: bounds.bottom
        }, lifespan / rnd.between(1, 5), Sinusoidal.InOut, true, 0, -1, true);
        this.add.tween(this.emitter).from({
          lifespan: lifespan / rnd.between(1, 5)
        }, lifespan, Sinusoidal.InOut, true, 0, -1, true);
      }
    },
    fireball: {
      create: function() {
        var frequency, lifespan, maxParticles;
        lifespan = 5 * SECOND;
        frequency = 100;
        this.emitter = this.add.batchEmitter(this.world.centerX, this.world.centerY, maxParticles = 100).setGravity(-50).setAlphaTween(0.1, 0, lifespan, Cubic.Out).setDrag(5, 5).setScaleTween(0, 8, 0, 8, lifespan, Cubic.Out).setSpeed(-20, 20, -20, 20).makeParticles('fireball').flow(lifespan, 100, maxParticles * frequency / lifespan);
      },
      update: function() {
        var activePointer;
        activePointer = this.input.activePointer;
        if (activePointer.isDown) {
          this.emitter.emitX = linear(this.emitter.emitX, activePointer.x, 1 / 60);
          this.emitter.emitY = linear(this.emitter.emitY, activePointer.y, 1 / 60);
        }
      }
    },
    fireworks: {
      create: function() {
        var frequency, lifespan, maxParticles;
        lifespan = 4 * SECOND;
        frequency = 2 * SECOND;
        this.bounds = this.world.bounds.clone();
        this.emitter = this.add.batchEmitter(this.world.centerX, this.world.centerY, maxParticles = 1000);
        this.emitter.resetChild = this.emitterResetChild.bind(this.emitter);
        this.emitter.setGravity(500).setAlphaTween(1, 0, lifespan, Cubic.In).setScaleTween(0.5, 0, 0.5, 0, lifespan, Cubic.Out).setSpeed(-1000, 1000).makeParticles('star').flow(lifespan, frequency, maxParticles * frequency / lifespan);
        this.time.events.loop(frequency / 2, this.moveEmitter, this);
      },
      update: function() {
        var child, drag, i, len, ref1;
        drag = 59 / 60;
        ref1 = this.emitter.children;
        for (i = 0, len = ref1.length; i < len; i++) {
          child = ref1[i];
          if (!child.visible) {
            continue;
          }
          child.vx *= drag;
          child.vy *= drag;
        }
      },
      emitterResetChild: function(child) {
        var angle, rnd, speed;
        rnd = this.game.rnd;
        child.reset(this.emitX, this.emitY);
        child.lifespan = this.lifespan;
        angle = TURN * Math.random();
        speed = rnd.realInRange(this.minParticleSpeed.x, this.maxParticleSpeed.x);
        child.vx = speed * cos(angle);
        child.vy = speed * sin(angle);
        return child;
      },
      moveEmitter: function() {
        this.emitter.emitX = this.bounds.randomX;
        this.emitter.emitY = this.bounds.randomY;
      }
    },
    fpsProblem: {
      "private": true,
      create: function() {
        this.add.text(0, 0, "Stopped because of low FPS :(", STYLE).alignIn(this.world.bounds, Phaser.CENTER);
      },
      render: function() {
        this.game.lockRender = true;
        console.log("lockRender", this.game.lockRender);
      }
    },
    fog: {
      create: function() {
        var height, lifespan, maxParticles, ref1, width;
        ref1 = this.world, height = ref1.height, width = ref1.width;
        lifespan = 10 * SECOND;
        this.emitter = this.add.batchEmitter(this.world.bounds.left, this.world.bounds.top, maxParticles = 1000).setAlphaTween(0, 0.1, lifespan, Quadratic.InOut, true).setScale(5, 15).setSize(this.world.width, this.world.height).setXSpeed(-50, 50).setYSpeed(-25, 25).makeParticles('fog').flow(10 * SECOND, 100, maxParticles / 100);
      }
    },
    kaleidoscope: {
      create: function() {
        var lifespan, maxParticles;
        lifespan = 5 * SECOND;
        this.emitter = this.add.batchEmitter(this.world.bounds.left, this.world.bounds.top, maxParticles = 1000).copyAreaFrom(this.world.bounds).setAlphaTween(0, 0.25, lifespan, Sinusoidal.InOut, true).setGravity(20).setScale(1, 3).setSpeed(100).setRotation(TURN / 5, TURN / 5).makeParticles('gameboy', [0, 1, 2, 3, 4], maxParticles / 5).flowAuto(10 * SECOND, 100, null);
      }
    },
    profile: {
      create: function() {
        var game, height, maxParticles, n, ref1, width;
        game = this.game;
        ref1 = this.world, height = ref1.height, width = ref1.width;
        console.profile("create: '" + this.key + "'");
        this.emitter = this.add.batchEmitter(this.world.bounds.left, this.world.bounds.bottom, maxParticles = 10000).setAngularDrag(TURN / 60).setDrag(10, 0).setGravity(height / 8).setRotation(-TURN, TURN).setXSpeed(width / -4, width / 4).setYSpeed(height / -2, 0).makeParticles('balls', [0, 1, 2, 3, 4], ~~(maxParticles / 5)).flow(5 * SECOND, 20, maxParticles / 250);
        console.profileEnd();
        n = 1000;
        game.enableStep();
        console.profile("emitter.update() x" + n);
        while (n--) {
          game.step();
          this.emitter.update();
        }
        console.profileEnd();
        game.disableStep();
        console.profile("update: '" + this.key + "'");
        this.time.events.add(5 * SECOND, console.profileEnd, console);
      }
    },
    pulsar: {
      preload: function() {
        var bm, pulsar, tx;
        bm = this.game.make.bitmapData(2, 1).rect(0, 0, 1, 1, "rgb(0,0,255)").rect(1, 0, 1, 1, "rgb(0,255,255)");
        tx = bm.generateTexture("pulsarTexture");
        console.log("pulsarTexture", tx);
        console.log("pulsarTexture.baseTexture.source", tx.baseTexture.source);
        this.cache.addSpriteSheet("pulsar", null, tx.baseTexture.source, 1, 1, 2, 0, 0);
        pulsar = this.cache.getImage("pulsar", true);
        if (!pulsar.frameData) {
          console.timeStamp("Missing frameData");
          console.warn("Missing frameData", tx.baseTexture.source);
        }
      },
      create: function() {
        var maxParticles;
        maxParticles = 5000;
        this.emitter = new Phaser.BatchEmitter(this.game).configure(this.world.centerX, this.world.centerY, maxParticles / 2).setAlpha(0.01, 0.02).setDrag(50, 30).setGravity(100).setRotation(-TURN, TURN).setScale(1, 100).setXSpeed(-500, 500).setYSpeed(-500, 500).makeParticles("pulsar", [0, 1]).shuffle().flow(1000, 100, maxParticles / 10);
      }
    },
    rain: {
      create: function() {
        var height, maxParticles, ref1, width;
        ref1 = this.world, height = ref1.height, width = ref1.width;
        this.wind = new Phaser.Point(width / 8, height / 16);
        this.add.tween(this.wind).to({
          x: width / -8,
          y: height / -16
        }, 60000, Sinusoidal.InOut, true, 0, -1, true);
        this.emitter = this.add.batchEmitter(this.world.bounds.left, this.world.bounds.top, maxParticles = 5000).setAlpha(0.25, 0.75).setGravity(height / 50).setScale(0.5, 1).setSize(this.world.width, this.world.height).setXSpeed(width / -16, width / 16).setYSpeed(height * 0.5, height * 1.5).makeParticles('rain').flow(1000, 100, maxParticles / 10);
      },
      update: function() {
        var child, i, len, physicsElapsed, ref1, ref2, x, y;
        physicsElapsed = this.time.physicsElapsed;
        ref1 = this.wind, x = ref1.x, y = ref1.y;
        x *= physicsElapsed;
        y *= physicsElapsed;
        ref2 = this.emitter.children;
        for (i = 0, len = ref2.length; i < len; i++) {
          child = ref2[i];
          if (!child.visible) {
            continue;
          }
          child.vx += x;
          child.vy += y;
          child.rotation = atan2(child.vx, child.vy);
        }
      }
    },
    rabbits: {
      create: function() {
        var height, maxParticles, ref1, width;
        ref1 = this.world, height = ref1.height, width = ref1.width;
        this.emitter = this.add.batchEmitter(this.world.bounds.left, this.world.centerY, maxParticles = 10000).setGravity(100).setSpeed(-100, 100, -200, 0).makeParticles('rabbit').flow(5000, 20, 40);
        this.add.tween(this.emitter).to({
          emitX: this.world.bounds.right
        }, 5000, Sinusoidal.InOut, true, 0, -1, true);
      }
    },
    raster: {
      create: function() {
        var lifespan, maxParticles;
        lifespan = 10 * SECOND;
        this.emitter = this.add.batchEmitter(this.world.bounds.left, this.world.bounds.top, maxParticles = 10).setAlphaTween(0, 0.25, lifespan, Sinusoidal.InOut, true).setAnchor(0, 0).setScale(100, 100, 1, 1).setYSpeed(this.world.height / -5, this.world.height / 5).makeParticles('raster').flowAuto(5000, null, 1);
        console.log(this.emitter.children[0]);
      }
    },
    snow: {
      create: function() {
        var height, left, maxParticles, ref1, top, width;
        ref1 = this.world, height = ref1.height, left = ref1.left, top = ref1.top, width = ref1.width;
        this.wind = new Phaser.Point(width / 8, height / 16);
        this.add.tween(this.wind).to({
          x: width / -8,
          y: height / -16
        }, 10000, Sinusoidal.InOut, true, 0, -1, true);
        this.emitter = this.add.batchEmitter(this.world.bounds.left, this.world.bounds.top, maxParticles = 1000).setAlpha(0.25, 0.75).setRotation(TURN / -2, TURN / 2).setScale(0.125, 0.5).setSize(this.world.width, 0).setXSpeed(width / -25, width / 25).setYSpeed(height * 0.075, height * 0.125).makeParticles('snowflakes', [0, 1, 2, 3, 4], ~~(maxParticles / 5)).shuffle().flowAuto(10 * SECOND, 250, null);
      },
      update: function() {
        var child, height, i, len, physicsElapsed, ref1, ref2, ref3, width, x, y;
        ref1 = this.world, height = ref1.height, width = ref1.width;
        physicsElapsed = this.time.physicsElapsed;
        ref2 = this.wind, x = ref2.x, y = ref2.y;
        x *= physicsElapsed / 10;
        y *= physicsElapsed / 10;
        ref3 = this.emitter.children;
        for (i = 0, len = ref3.length; i < len; i++) {
          child = ref3[i];
          if (!child.visible) {
            continue;
          }
          child.vx += x * child.scale.x;
          if (child.x < 0) {
            child.x += width;
          } else if (child.x > width) {
            child.x -= width;
          }
          if (child.y < 0) {
            child.y += height;
          } else if (child.y > height) {
            child.y -= height;
          }
        }
      }
    },
    starfield: {
      create: function() {
        var height, interval, lifespan, maxParticles, ref1, width;
        ref1 = this.world, height = ref1.height, width = ref1.width;
        maxParticles = 10000;
        lifespan = 1000;
        interval = 100;
        this.emitter = this.add.batchEmitter(this.world.bounds.left, this.world.bounds.top, maxParticles).setAlphaTween(0, 1).setPosition(this.world.centerX, this.world.centerY).setSpeed(width / -2, width / 2).makeParticles('star2').flow(lifespan, interval, maxParticles / 10);
      }
    }
  };

  startGame = function() {
    var game, key, state;
    this.GAME = game = new Phaser.Game({
      enableDebug: false,
      height: window.innerHeight,
      width: window.innerWidth,
      scaleMode: Phaser.ScaleManager.NO_SCALE
    });
    for (key in states) {
      state = states[key];
      game.state.add(key, state);
    }
    game.state.start("boot");
    return game;
  };

  startGame.call(this);

}).call(this);
